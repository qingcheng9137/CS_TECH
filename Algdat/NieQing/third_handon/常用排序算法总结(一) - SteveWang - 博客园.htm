<!DOCTYPE HTML>
<!-- saved from url=(0048)http://www.cnblogs.com/eniac12/p/5329396.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cn"><HEAD><META content="IE=10.0000" 
http-equiv="X-UA-Compatible">
 
<META charset="utf-8"> 
<META name="viewport" content="width=device-width, initial-scale=1"> 
<TITLE>常用排序算法总结(一) - SteveWang - 博客园</TITLE> <LINK href="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/blog-common.css" 
rel="stylesheet" type="text/css"> <LINK id="MainCss" href="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/bundle-KJC.css" 
rel="stylesheet" type="text/css"> <LINK href="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/221334.css" 
rel="stylesheet" type="text/css"> <LINK id="mobile-style" href="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/bundle-KJC-mobile.css" 
rel="stylesheet" type="text/css" media="only screen and (max-width: 767px)"> 
<LINK title="RSS" href="http://www.cnblogs.com/eniac12/rss" rel="alternate" 
type="application/rss+xml"> <LINK title="RSD" href="http://www.cnblogs.com/eniac12/rsd.xml" 
rel="EditURI" type="application/rsd+xml"> <LINK href="http://www.cnblogs.com/eniac12/wlwmanifest.xml" 
rel="wlwmanifest" type="application/wlwmanifest+xml"> 
<SCRIPT src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/jquery-2.2.0.min.js"></SCRIPT>
 
<SCRIPT type="text/javascript">var currentBlogApp = 'eniac12', cb_enable_mathjax=false;var isLogined=false;</SCRIPT>
 
<SCRIPT src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/blog-common.js" type="text/javascript"></SCRIPT>
 
<META name="GENERATOR" content="MSHTML 11.00.10570.1001"></HEAD> 
<BODY><A name="top"></A> 
<TABLE width="100%" class="Framework" cellspacing="0" cellpadding="0">
  <TBODY>
  <TR>
    <TD colspan="3">
      <DIV id="top">
      <TABLE cellspacing="0" cellpadding="10">
        <TBODY>
        <TR>
          <TD nowrap="">
            <H1><A class="headermaintitle" id="Header1_HeaderTitle" href="http://www.cnblogs.com/eniac12/">逝者如斯,不舍昼夜</A></H1>
            			尘世中一个迷途小书童，读书太少，想得太多		 </TD></TR></TBODY></TABLE></DIV>
      <DIV id="sub">
      <DIV id="sub-right">
      <DIV id="blog_stats">
      <DIV class="BlogStats">posts - 72, comments - 36, trackbacks - 0, articles 
      - 0</DIV></DIV></DIV>	&nbsp;<A id="blog_nav_sitehome" href="http://www.cnblogs.com/">博客园</A>&nbsp;:: 
       <A id="blog_nav_myhome" 
      href="http://www.cnblogs.com/eniac12/">首页</A>&nbsp;:: <A id="blog_nav_newpost" 
      href="https://i.cnblogs.com/EditPosts.aspx?opt=1" 
      rel="nofollow">新随笔</A>&nbsp;:: <A id="blog_nav_contact" accesskey="9" 
      href="https://msg.cnblogs.com/send/SteveWang" 
      rel="nofollow">联系</A>&nbsp;:: <A id="blog_nav_rss" href="http://www.cnblogs.com/eniac12/rss">订阅</A> 
      <A class="XMLLink" id="blog_nav_rss_image" href="http://www.cnblogs.com/eniac12/rss"><IMG 
      alt="订阅" 
      src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/xml.gif"></A>&nbsp;:: <A 
      id="blog_nav_admin" href="https://i.cnblogs.com/" rel="nofollow">管理</A> 
      </DIV></TD></TR>
  <TR>
    <TD class="LeftCell">
      <DIV id="leftmenu">
      <DIV id="blog-calendar" style="display: none;"></DIV>
<SCRIPT type="text/javascript">loadBlogDefaultCalendar();</SCRIPT>
      		             
      <DIV id="cell"><IMG align="left" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/icon-group.jpg" 
      vspace="2" hspace="5">
      <H3>公告</H3>
      <DIV id="news">
      <DIV id="blog-news"></DIV>
<SCRIPT type="text/javascript">loadBlogNews();</SCRIPT>
       </DIV></DIV>
      <DIV id="blog-sidecolumn"></DIV>
<SCRIPT type="text/javascript">loadBlogSideColumn();</SCRIPT>
      			 </DIV></TD>
    <TD class="MainCell">
      <DIV id="main">
      <DIV id="post_detail">
      <DIV class="post">
      <DIV class="posthead">
      <H2><A class="singleposttitle" id="cb_post_title_url" href="http://www.cnblogs.com/eniac12/p/5329396.html">常用排序算法总结(一)</A>
      			 </H2>Posted on <SPAN id="post-date">2016-03-28 22:13</SPAN> <A href="http://www.cnblogs.com/eniac12/">SteveWang</A> 
      阅读(<SPAN id="post_view_count">...</SPAN>) 评论(<SPAN 
      id="post_comment_count">...</SPAN>)  <A href="https://i.cnblogs.com/EditPosts.aspx?postid=5329396" 
      rel="nofollow">编辑</A> <A onclick="AddToWz(5329396);return false;" href="http://www.cnblogs.com/eniac12/p/5329396.html#">收藏</A>
      			 
<SCRIPT type="text/javascript">var allowComments=true,cb_blogId=221334,cb_entryId=5329396,cb_blogApp=currentBlogApp,cb_blogUserGuid='2ea8bbf9-11d9-e411-b908-9dcfd8948a71',cb_entryCreatedDate='2016/3/28 22:13:00';loadViewCount(cb_entryId);var cb_postType=1;</SCRIPT>
      					 </DIV>
      <DIV class="postbody">
      <DIV class="blogpost-body" id="cnblogs_post_body">
      <H3><SPAN style="line-height: 1.5;">　　目录</SPAN></H3>
      <UL>
        <LI><SPAN style="line-height: 1.5; font-family: 宋体; font-size: 15px;"><A 
        href="http://www.cnblogs.com/eniac12/p/5329396.html#s1">冒泡排序</A>　　</SPAN> 
        <UL>
          <LI><SPAN 
          style="line-height: 1.5; font-family: 宋体; font-size: 15px;"><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s12">鸡尾酒排序</A>　　</SPAN></LI></UL></LI>
        <LI><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s2"><SPAN 
        style="line-height: 1.5; font-family: 宋体; font-size: 15px;">选择排序</SPAN></A></LI>
        <LI><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s3"><SPAN 
        style="line-height: 1.5; font-family: 宋体; font-size: 15px;">插入排序</SPAN></A> 
        <UL>
          <LI><SPAN 
          style="line-height: 1.5; font-family: 宋体; font-size: 15px;"><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s31">二分插入排序</A>　　</SPAN></LI>
          <LI><SPAN 
          style="line-height: 1.5; font-family: 宋体; font-size: 15px;"><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s32">希尔排序</A>　　</SPAN></LI></UL></LI>
        <LI><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s4"><SPAN 
        style="line-height: 1.5; font-family: 宋体; font-size: 15px;">归并排序</SPAN></A></LI>
        <LI><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s5"><SPAN 
        style="line-height: 1.5; font-family: 宋体; font-size: 15px;">堆排序</SPAN></A></LI>
        <LI><A href="http://www.cnblogs.com/eniac12/p/5329396.html#s6"><SPAN 
        style="line-height: 1.5; font-family: 宋体; font-size: 15px;">快速排序</SPAN></A></LI></UL>
      <P>&nbsp;</P>
      <P><SPAN 
      style="line-height: 1.5;">　　我们通常所说的排序算法往往指的是<STRONG>内部排序算法</STRONG>，即数据记录在内存中进行排序。</SPAN></P>
      <P><SPAN style="line-height: 1.5;">　　</SPAN>排序算法大体可分为两种：</P>
      <P>　　　　一种是<STRONG>比较排序</STRONG>，时间复杂度O(nlogn) ~ O(n^2)，主要有：<STRONG style="line-height: 1.5;">冒泡排序</STRONG><SPAN 
      style="line-height: 1.5;">，</SPAN><STRONG 
      style="line-height: 1.5;">选择排序</STRONG><SPAN 
      style="line-height: 1.5;">，</SPAN><STRONG 
      style="line-height: 1.5;">插入排序</STRONG><SPAN 
      style="line-height: 1.5;">，</SPAN><STRONG 
      style="line-height: 1.5;">归并排序</STRONG><SPAN 
      style="line-height: 1.5;">，</SPAN><STRONG 
      style="line-height: 1.5;">堆排序</STRONG><SPAN 
      style="line-height: 1.5;">，</SPAN><STRONG 
      style="line-height: 1.5;">快速排序</STRONG><SPAN 
      style="line-height: 1.5;">等。</SPAN></P>
      <P>　　　　另一种是<STRONG>非比较排序</STRONG>，时间复杂度可以达到O(n)，主要有：<STRONG>计数排序</STRONG>，<STRONG>基数排序</STRONG>，<STRONG>桶排序</STRONG>等。</P>
      <P>　　这里我们来探讨一下常用的比较排序算法，非比较排序算法将在<A href="http://www.cnblogs.com/eniac12/p/5332117.html" 
      target="_blank">下一篇文章</A>中介绍。下表给出了常见比较排序算法的性能：</P>
      <P>　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160503202729044-614991035.jpg"></P>
      <P>&nbsp;</P>
      <P>　　有一点我们很容易忽略的是<STRONG>排序算法的稳定性</STRONG>(腾讯校招2016笔试题曾考过)。</P>
      <P>　　排序算法稳定性的简单形式化定义为：<STRONG>如果A<SUB>i</SUB> = 
      A<SUB>j</SUB>，排序前A<SUB>i</SUB>在A<SUB>j</SUB>之前，排序后A<SUB>i</SUB>还在A<SUB>j</SUB>之前，则称这种排序算法是稳定的。</STRONG>通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</P>
      <P>　　对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</P>
      <P>　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] &gt;= A[i + 
      1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</P>
      <P>　　其次，说一下排序算法稳定性的好处。<STRONG>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</STRONG>基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s1"></A>冒泡排序(Bubble Sort)</H2>
      <P>&nbsp;</P>
      <P>　　冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。</P>
      <P>　　冒泡排序算法的运作如下：</P>
      <OL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>针对所有的元素重复以上的步骤，除了最后一个。</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</SPAN></LI></OL>
      <P>　　由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Swap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> j)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> temp =<SPAN style="color: rgb(0, 0, 0);"> A[i];
    A[i] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> A[j];
    A[j] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> temp;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> BubbleSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; j &lt; n - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; j++)         <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 每次最大元素就像气泡一样"浮"到数组的最后</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n - <SPAN style="color: rgb(128, 0, 128);">1</SPAN> - j; i++) <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 依次比较相邻的两个元素,使较大的那个向后移</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[i] &gt; A[i + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>])            <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 如果条件改成A[i] &gt;= A[i + 1],则变为不稳定的排序算法</SPAN>
<SPAN style="color: rgb(0, 0, 0);">            {
                Swap(A, i, i </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">);
            }
        }
    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN> };    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大冒泡排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    BubbleSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">冒泡排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下</P>
      <P>　　　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160329100443676-1647340243.gif"></P>
      <P>　　使用冒泡排序为一列数字进行排序的过程如右图所示：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160329100034660-1420925220.gif"></P>
      <P>　　尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s12"></A>冒泡排序的改进：<STRONG>鸡尾酒排序</STRONG></H2>
      <P>&nbsp;</P>
      <P><STRONG>　　</STRONG>鸡尾酒排序，也叫<STRONG>定向冒泡排序</STRONG>，是冒泡排序的一种改进。此算法与冒泡排序的不同处在于<STRONG>从低到高然后从高到低</STRONG>，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</P>
      <P>　　鸡尾酒排序的代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Swap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> j)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> temp =<SPAN style="color: rgb(0, 0, 0);"> A[i];
    A[i] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> A[j];
    A[j] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> temp;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> CocktailSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> left = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>;                            <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 初始化边界</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right = n - <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (left &lt;<SPAN style="color: rgb(0, 0, 0);"> right)
    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = left; i &lt; right; i++)   <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 前半轮,将最大元素放到后面</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[i] &gt; A[i + <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">])
            {
                Swap(A, i, i </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">);
            }
        }
        right</SPAN>--<SPAN style="color: rgb(0, 0, 0);">;
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = right; i &gt; left; i--)   <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 后半轮,将最小元素放到前面</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[i - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>] &gt;<SPAN style="color: rgb(0, 0, 0);"> A[i])
            {
                Swap(A, i </SPAN>- <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">, i);
            }
        }
        left</SPAN>++<SPAN style="color: rgb(0, 0, 0);">;
    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN> };   <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大定向冒泡排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    CocktailSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">鸡尾酒排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　使用鸡尾酒排序为一列数字进行排序的过程如右图所示：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328160227004-680964122.gif"></P>
      <P>　　以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</P>
      <P>　　</P>
      <P><SPAN style="line-height: 1.5;"><STRONG>　　</STRONG></SPAN></P>
      <H2><SPAN style="line-height: 1.5;"><STRONG>　　<A 
      name="s2"></A>选择排序(Selection Sort)</STRONG></SPAN></H2>
      <P>&nbsp;</P>
      <P><SPAN 
      style="line-height: 1.5;">　　选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</SPAN></P>
      <P><SPAN 
      style="line-height: 1.5;">　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</SPAN></P>
      <P><SPAN style="line-height: 1.5;">　　选择排序的</SPAN><SPAN style="line-height: 1.5;">代码如下：</SPAN></P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 不稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Swap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> j)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> temp =<SPAN style="color: rgb(0, 0, 0);"> A[i];
    A[i] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> A[j];
    A[j] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> temp;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> SelectionSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; i++)         <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> i为已排序序列的末尾</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> min =<SPAN style="color: rgb(0, 0, 0);"> i;
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = i + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; j &lt; n; j++)     <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 未排序序列</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[j] &lt; A[min])              <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 找出未排序序列中的最小值</SPAN>
<SPAN style="color: rgb(0, 0, 0);">            {
                min </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> j;
            }
        }
        </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (min !=<SPAN style="color: rgb(0, 0, 0);"> i)
        {
            Swap(A, min, i);    </SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        }
    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">9</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN>, <SPAN style="color: rgb(128, 0, 128);">0</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN> }; <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大选择排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    SelectionSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">选择排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>&nbsp;　　上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图　　<IMG 
      alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160329102006082-273282321.gif"></P>
      <P>&nbsp;</P>
      <P>　　使用选择排序为一列数字进行排序的宏观过程：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328195305723-701227998.gif"></P>
      <P>　　<STRONG>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</STRONG></P>
      <P><STRONG>　　</STRONG>比如序列：{ <SPAN 
      style="color: rgb(0, 0, 255);">5</SPAN>, 8, <SPAN style="color: rgb(0, 0, 255);">5</SPAN>, 
      <SPAN style="color: rgb(255, 0, 0);">2</SPAN>, 9 
      }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s3"></A>插入排序(Insertion Sort)</H2>
      <P>&nbsp;</P>
      <P>　　插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</P>
      <P>　　　　　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160329094816957-1860272498.jpg"></P>
      <P>&nbsp;</P>
      <P>　　对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</P>
      <P>　　插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</P>
      <P>　　具体算法描述如下：</P>
      <OL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>从第一个元素开始，该元素可以认为已经被排序</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>取出下一个元素，在已经排序的元素序列中从后向前扫描</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>如果该元素（已排序）大于新元素，将该元素移到下一位置</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>将新元素插入到该位置后</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>重复步骤2~5</SPAN></LI></OL>
      <P>　　插入排序的代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 ------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> InsertionSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; i &lt; n; i++)         <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 类似抓扑克牌排序</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> <SPAN style="color: rgb(0, 0, 255);">get</SPAN> = A[i];                 <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 右手抓到一张扑克牌</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = i - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;                  <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 拿在左手上的牌总是排序好的</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">while</SPAN> (j &gt;= <SPAN style="color: rgb(128, 0, 128);">0</SPAN> &amp;&amp; A[j] &gt; <SPAN style="color: rgb(0, 0, 255);">get</SPAN>)    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 将抓到的牌与手牌从右向左进行比较</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            A[j </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN>] = A[j];            <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 如果该手牌比抓到的牌大，就将其右移</SPAN>
            j--<SPAN style="color: rgb(0, 0, 0);">;
        }
        A[j </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN>] = <SPAN style="color: rgb(0, 0, 255);">get</SPAN>; <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN> };<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大插入排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    InsertionSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">插入排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>&nbsp;　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</P>
      <P>　　　　　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160329095145504-1018443290.gif"></P>
      <P>　　　　　　</P>
      <P>　　使用插入排序为一列数字进行排序的宏观过程：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328201132394-577931661.gif"></P>
      <P>　　插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 
      插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s31"></A>插入排序的改进：二分插入排序</H2>
      <P>&nbsp;</P>
      <P>　　对于插入排序，如果比较操作的代价比交换操作大的话，可以采用<STRONG>二分查找法</STRONG>来减少比较操作的次数，我们称为<STRONG>二分插入排序</STRONG>，代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> InsertionSortDichotomy(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> <SPAN style="color: rgb(0, 0, 255);">get</SPAN> = A[i];                    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 右手抓到一张扑克牌</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">int</SPAN> left = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>;                    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 拿在左手上的牌总是排序好的，所以可以用二分法</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right = i - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;                <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 手牌左右边界进行初始化</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">while</SPAN> (left &lt;= right)            <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 采用二分法定位新牌的位置</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> mid = (left + right) / <SPAN style="color: rgb(128, 0, 128);">2</SPAN><SPAN style="color: rgb(0, 0, 0);">;
            </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[mid] &gt; <SPAN style="color: rgb(0, 0, 255);">get</SPAN><SPAN style="color: rgb(0, 0, 0);">)
                right </SPAN>= mid - <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
            </SPAN><SPAN style="color: rgb(0, 0, 255);">else</SPAN><SPAN style="color: rgb(0, 0, 0);">
                left </SPAN>= mid + <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
        }
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = i - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; j &gt;= left; j--)    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 将欲插入新牌位置右边的牌整体向右移动一个单位</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            A[j </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN>] =<SPAN style="color: rgb(0, 0, 0);"> A[j];
        }
        A[left] </SPAN>= <SPAN style="color: rgb(0, 0, 255);">get</SPAN>;                    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 将抓到的牌插入手牌</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
}


</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">9</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN> };<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大二分插入排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    InsertionSortDichotomy(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">二分插入排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s32"></A>插入排序的更高效改进：希尔排序(Shell Sort)</H2>
      <P>&nbsp;</P>
      <P>　　希尔排序，也叫<STRONG>递减增量排序</STRONG>，是插入排序的一种更高效的改进版本。希尔排序是<STRONG>不稳定</STRONG>的排序算法。</P>
      <P>　　希尔排序是基于插入排序的以下两点性质而提出改进方法的：</P>
      <UL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</SPAN></LI></UL>
      <P>　　希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<BR>　　假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</P>
      <P>　　希尔排序的代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;  

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- O(n)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- 根据步长序列的不同而不同。
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 不稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> ShellSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> h = <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (h &lt;= n)                          <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 生成初始增量</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        h </SPAN>= <SPAN style="color: rgb(128, 0, 128);">3</SPAN> * h + <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    }
    </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (h &gt;= <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">)
    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = h; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
        {
            </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = i -<SPAN style="color: rgb(0, 0, 0);"> h;
            </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> <SPAN style="color: rgb(0, 0, 255);">get</SPAN> =<SPAN style="color: rgb(0, 0, 0);"> A[i];
            </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (j &gt;= <SPAN style="color: rgb(128, 0, 128);">0</SPAN> &amp;&amp; A[j] &gt; <SPAN style="color: rgb(0, 0, 255);">get</SPAN><SPAN style="color: rgb(0, 0, 0);">)
            {
                A[j </SPAN>+ h] =<SPAN style="color: rgb(0, 0, 0);"> A[j];
                j </SPAN>= j -<SPAN style="color: rgb(0, 0, 0);"> h;
            }
            A[j </SPAN>+ h] = <SPAN style="color: rgb(0, 0, 255);">get</SPAN><SPAN style="color: rgb(0, 0, 0);">;
        }
        h </SPAN>= (h - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>) / <SPAN style="color: rgb(128, 0, 128);">3</SPAN>;                    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 递减增量</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">9</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN> };<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大希尔排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    ShellSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">希尔排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　以23, 10, 4, 1的步长序列进行希尔排序：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328205313363-2043878119.gif"></P>
      <P>　　<STRONG>希尔排序是不稳定的排序算法，</STRONG>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。</P>
      <P><STRONG>　　</STRONG>比如序列：{&nbsp;3, 5,&nbsp;10,&nbsp;<SPAN style="color: rgb(255, 0, 0);">8</SPAN>, 
      7, 2, <SPAN style="color: rgb(0, 0, 255);">8</SPAN>, 1, 20, 6 
      }，h=2时分成两个子序列&nbsp;{&nbsp;3, 10, 7, <SPAN 
      style="color: rgb(0, 0, 255);">8</SPAN>, 20 } 和&nbsp;&nbsp;{&nbsp;5, <SPAN 
      style="color: rgb(255, 0, 0);">8</SPAN>, 2, 1, 6 } 
      ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到&nbsp;{&nbsp;3,&nbsp;<SPAN style="line-height: 1.5;">7</SPAN><SPAN 
      style="line-height: 1.5;">,&nbsp;</SPAN><SPAN style="color: rgb(0, 0, 255); line-height: 1.5;">8</SPAN><SPAN 
      style="line-height: 1.5;">,&nbsp;</SPAN><SPAN 
      style="line-height: 1.5;">10</SPAN><SPAN style="line-height: 1.5;">, 20 } 
      和 {&nbsp;</SPAN><SPAN style="line-height: 1.5;">1</SPAN><SPAN style="line-height: 1.5;">,&nbsp;</SPAN><SPAN 
      style="line-height: 1.5;">2</SPAN><SPAN 
      style="line-height: 1.5;">,&nbsp;</SPAN><SPAN 
      style="line-height: 1.5;">5</SPAN><SPAN 
      style="line-height: 1.5;">,&nbsp;</SPAN><SPAN 
      style="line-height: 1.5;">6</SPAN><SPAN 
      style="line-height: 1.5;">,&nbsp;</SPAN><SPAN style="color: rgb(255, 0, 0); line-height: 1.5;">8</SPAN><SPAN 
      style="line-height: 1.5;">&nbsp;} ，即&nbsp;{&nbsp;3, 1,&nbsp;7,&nbsp;2, 
      <SPAN style="color: rgb(0, 0, 255);">8</SPAN>, 5,&nbsp;10, 6, 20, <SPAN 
      style="color: rgb(255, 0, 0);">8</SPAN> } ，两个8的相对次序发生了改变。</SPAN></P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s4"></A>归并排序(Merge Sort)</H2>
      <P>&nbsp;</P>
      <P>　　归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。</P>
      <P>　　归并排序的实现分为<STRONG>递归实现</STRONG>与<STRONG>非递归(迭代)实现</STRONG>。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。</P>
      <P>　　归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，<STRONG>归并操作</STRONG>步骤如下：</P>
      <OL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'><STRONG>申请空间</STRONG>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>设定两个指针，最初位置分别为两个已经排序序列的起始位置</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>重复步骤3直到某一指针到达序列尾</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>将另一序列剩下的所有元素直接复制到合并序列尾</SPAN></LI></OL>
      <P><SPAN 
      style='font-family: "Microsoft YaHei"; font-size: 15px;'>　　归并排序的代码如下：</SPAN></P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;<SPAN style="color: rgb(0, 0, 0);">
#include </SPAN>&lt;limits.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(n)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 稳定</SPAN>


<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Merge(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> left, <SPAN style="color: rgb(0, 0, 255);">int</SPAN> mid, <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right)<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> len = right - left + <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> *temp = <SPAN style="color: rgb(0, 0, 255);">new</SPAN> <SPAN style="color: rgb(0, 0, 255);">int</SPAN>[len];       <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 辅助空间O(n)</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> index = <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = left;                   <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 前一数组的起始元素</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> j = mid + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;                <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 后一数组的起始元素</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">while</SPAN> (i &lt;= mid &amp;&amp; j &lt;=<SPAN style="color: rgb(0, 0, 0);"> right)
    {
        temp[index</SPAN>++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 带等号保证归并排序的稳定性</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
    </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (i &lt;=<SPAN style="color: rgb(0, 0, 0);"> mid)
    {
        temp[index</SPAN>++] = A[i++<SPAN style="color: rgb(0, 0, 0);">];
    }
    </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (j &lt;=<SPAN style="color: rgb(0, 0, 0);"> right)
    {
        temp[index</SPAN>++] = A[j++<SPAN style="color: rgb(0, 0, 0);">];
    }
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> k = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; k &lt; len; k++<SPAN style="color: rgb(0, 0, 0);">)
    {
        A[left</SPAN>++] =<SPAN style="color: rgb(0, 0, 0);"> temp[k];
    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> MergeSortRecursion(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> left, <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right)    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 递归实现的归并排序(自顶向下)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (left == right)    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 当待排序的序列长度为1时，递归开始回溯，进行merge操作</SPAN>
        <SPAN style="color: rgb(0, 0, 255);">return</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> mid = (left + right) / <SPAN style="color: rgb(128, 0, 128);">2</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    MergeSortRecursion(A, left, mid);
    MergeSortRecursion(A, mid </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">, right);
    Merge(A, left, mid, right);
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> MergeSortIteration(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> len)    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 非递归(迭代)实现的归并排序(自底向上)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> left, mid, right;<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; i &lt; len; i *= <SPAN style="color: rgb(128, 0, 128);">2</SPAN>)        <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 子数组的大小i初始为1，每轮翻倍</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        left </SPAN>= <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
        </SPAN><SPAN style="color: rgb(0, 0, 255);">while</SPAN> (left + i &lt; len)              <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 后一个子数组存在(需要归并)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            mid </SPAN>= left + i - <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">;
            right </SPAN>= mid + i &lt; len ? mid + i : len - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 后一个子数组大小可能不够</SPAN>
<SPAN style="color: rgb(0, 0, 0);">            Merge(A, left, mid, right);
            left </SPAN>= right + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;               <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 前一个子数组索引向后移动</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        }
    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A1[] = { <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN> };      <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大归并排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> A2[] = { <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN><SPAN style="color: rgb(0, 0, 0);"> };
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> n1 = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A1) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> n2 = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A2) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    MergeSortRecursion(A1, </SPAN><SPAN style="color: rgb(128, 0, 128);">0</SPAN>, n1 - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>);          <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 递归实现</SPAN>
    MergeSortIteration(A2, n2);                 <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 非递归实现</SPAN>
    printf(<SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">递归实现的归并排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n1; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A1[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">非递归实现的归并排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n2; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A2[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下　</P>
      <P>&nbsp;</P>
      <P>　　　　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328211743473-909317024.gif"></P>
      <P>　　使用归并排序为一列数字进行排序的宏观过程：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328211504519-1388466622.gif">　　</P>
      <P>　　归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇<A title="wang7010957" 
      href="http://www.jianshu.com/p/3ab5033074f1" target="_blank">博文</A>。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s5"></A>堆排序(Heap Sort)</H2>
      <P>　　</P>
      <P>　　堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。</P>
      <P>　　我们可以很容易的定义堆排序的过程：</P>
      <OL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>由输入的无序数组构造一个最大堆，作为初始的无序区</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>把堆顶元素（最大值）和堆尾元素互换</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>把堆（无序区）的尺寸缩小1，并调用heapify(A, 
        0)从新的堆顶元素开始进行堆调整</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>重复步骤2，直到堆的尺寸为1</SPAN></LI></OL>
      <P>　　堆排序的代码如下：</P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 -------------- 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 ---------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ O(1)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ------------ 不稳定</SPAN>


<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Swap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> j)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> temp =<SPAN style="color: rgb(0, 0, 0);"> A[i];
    A[i] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> A[j];
    A[j] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> temp;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> Heapify(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN> size)  <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从A[i]向下进行堆调整</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> left_child = <SPAN style="color: rgb(128, 0, 128);">2</SPAN> * i + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;         <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 左孩子索引</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right_child = <SPAN style="color: rgb(128, 0, 128);">2</SPAN> * i + <SPAN style="color: rgb(128, 0, 128);">2</SPAN>;        <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 右孩子索引</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> max = i;                        <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 选出当前结点与其左右孩子三者之中的最大值</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">if</SPAN> (left_child &lt; size &amp;&amp; A[left_child] &gt;<SPAN style="color: rgb(0, 0, 0);"> A[max])
        max </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> left_child;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (right_child &lt; size &amp;&amp; A[right_child] &gt;<SPAN style="color: rgb(0, 0, 0);"> A[max])
        max </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> right_child;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (max !=<SPAN style="color: rgb(0, 0, 0);"> i)
    {
        Swap(A, i, max);                </SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 把当前结点和它的最大(直接)子节点进行交换</SPAN>
        Heapify(A, max, size);          <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 递归调用，继续从当前结点向下进行堆调整</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> BuildHeap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n)           <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 建堆，时间复杂度O(n)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> heap_size =<SPAN style="color: rgb(0, 0, 0);"> n;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = heap_size / <SPAN style="color: rgb(128, 0, 128);">2</SPAN> - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>; i &gt;= <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i--) <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从每一个非叶结点开始向下进行堆调整</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        Heapify(A, i, heap_size);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN><SPAN style="color: rgb(0, 0, 0);"> heap_size;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> HeapSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> n)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> heap_size = BuildHeap(A, n);    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 建立一个最大堆</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">while</SPAN> (heap_size &gt; <SPAN style="color: rgb(128, 0, 128);">1</SPAN>)    　　　　　　 <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 堆（无序区）元素个数大于1，未完成排序</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        </SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素
        </SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</SPAN>
        Swap(A, <SPAN style="color: rgb(128, 0, 128);">0</SPAN>, --<SPAN style="color: rgb(0, 0, 0);">heap_size);
        Heapify(A, </SPAN><SPAN style="color: rgb(128, 0, 128);">0</SPAN>, heap_size);     <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    }
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">9</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN> };<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大堆排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    HeapSort(A, n);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">堆排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　堆排序算法的演示：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328213839160-2037856208.gif"></P>
      <P>　　动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。</P>
      <P><STRONG>　　堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</STRONG></P>
      <P><STRONG>　　</STRONG>比如序列：{ <SPAN style="color: rgb(0, 0, 0);">9</SPAN>, 
      <SPAN style="color: rgb(255, 0, 0);">5</SPAN>, 7,&nbsp;<SPAN style="color: rgb(0, 0, 255);">5</SPAN> 
      }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列&nbsp;{&nbsp;<SPAN style="color: rgb(0, 0, 255);">5</SPAN>, 
      <SPAN style="color: rgb(255, 0, 0);">5</SPAN>, 
      7,&nbsp;9&nbsp;}，再进行堆调整得到{&nbsp;7, <SPAN 
      style="color: rgb(255, 0, 0);">5</SPAN>,&nbsp;<SPAN style="color: rgb(0, 0, 255);">5</SPAN>,&nbsp;9&nbsp;}，重复之前的操作最后得到{ 
      <SPAN style="color: rgb(0, 0, 255);">5</SPAN>,&nbsp;<SPAN style="color: rgb(255, 0, 0);">5</SPAN>, 
      7,&nbsp;9&nbsp;}从而改变了两个5的相对次序。</P>
      <P>&nbsp;</P>
      <P>&nbsp;</P>
      <H2>　　<A name="s6"></A>快速排序(Quick Sort)</H2>
      <P>&nbsp;</P>
      <P>　　快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</P>
      <P>　　快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</P>
      <OL>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>从序列中挑出一个元素，作为"基准"(pivot).</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。</SPAN></LI>
        <LI><SPAN 
        style='font-family: "Microsoft YaHei"; font-size: 15px;'>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。</SPAN></LI></OL>
      <P><SPAN 
      style='font-family: "Microsoft YaHei"; font-size: 15px;'>　　快速排序的代码如下：</SPAN></P>
      <DIV class="cnblogs_code">
<PRE>#include &lt;stdio.h&gt;

<SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 分类 ------------ 内部比较排序
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 数据结构 --------- 数组
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 平均时间复杂度 ---- O(nlogn)
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       
</SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 稳定性 ---------- 不稳定</SPAN>

<SPAN style="color: rgb(0, 0, 255);">void</SPAN> Swap(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> i, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> j)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> temp =<SPAN style="color: rgb(0, 0, 0);"> A[i];
    A[i] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> A[j];
    A[j] </SPAN>=<SPAN style="color: rgb(0, 0, 0);"> temp;
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> Partition(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> left, <SPAN style="color: rgb(0, 0, 255);">int</SPAN> right)  <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 划分函数</SPAN>
<SPAN style="color: rgb(0, 0, 0);">{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> pivot = A[right];               <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 这里每次都选择最后一个元素作为基准</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> tail = left - <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;                <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> tail为小于基准的子数组最后一个元素的索引</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = left; i &lt; right; i++)  <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 遍历基准以外的其他元素</SPAN>
<SPAN style="color: rgb(0, 0, 0);">    {
        </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (A[i] &lt;= pivot)              <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 把小于等于基准的元素放到前一个子数组末尾</SPAN>
<SPAN style="color: rgb(0, 0, 0);">        {
            Swap(A, </SPAN>++<SPAN style="color: rgb(0, 0, 0);">tail, i);
        }
    }
    Swap(A, tail </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, right);           <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组
                                        </SPAN><SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">return</SPAN> tail + <SPAN style="color: rgb(128, 0, 128);">1</SPAN>;                    <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 返回基准的索引</SPAN>
<SPAN style="color: rgb(0, 0, 0);">}

</SPAN><SPAN style="color: rgb(0, 0, 255);">void</SPAN> QuickSort(<SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[], <SPAN style="color: rgb(0, 0, 255);">int</SPAN> left, <SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> right)
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">if</SPAN> (left &gt;=<SPAN style="color: rgb(0, 0, 0);"> right)
        </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN><SPAN style="color: rgb(0, 0, 0);">;
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> pivot_index = Partition(A, left, right); <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 基准的索引</SPAN>
    QuickSort(A, left, pivot_index - <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    QuickSort(A, pivot_index </SPAN>+ <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">, right);
}

</SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);"> main()
{
    </SPAN><SPAN style="color: rgb(0, 0, 255);">int</SPAN> A[] = { <SPAN style="color: rgb(128, 0, 128);">5</SPAN>, <SPAN style="color: rgb(128, 0, 128);">2</SPAN>, <SPAN style="color: rgb(128, 0, 128);">9</SPAN>, <SPAN style="color: rgb(128, 0, 128);">4</SPAN>, <SPAN style="color: rgb(128, 0, 128);">7</SPAN>, <SPAN style="color: rgb(128, 0, 128);">6</SPAN>, <SPAN style="color: rgb(128, 0, 128);">1</SPAN>, <SPAN style="color: rgb(128, 0, 128);">3</SPAN>, <SPAN style="color: rgb(128, 0, 128);">8</SPAN> }; <SPAN style="color: rgb(0, 128, 0);">//</SPAN><SPAN style="color: rgb(0, 128, 0);"> 从小到大快速排序</SPAN>
    <SPAN style="color: rgb(0, 0, 255);">int</SPAN> n = <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(A) / <SPAN style="color: rgb(0, 0, 255);">sizeof</SPAN>(<SPAN style="color: rgb(0, 0, 255);">int</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    QuickSort(A, </SPAN><SPAN style="color: rgb(128, 0, 128);">0</SPAN>, n - <SPAN style="color: rgb(128, 0, 128);">1</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">快速排序结果：</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">for</SPAN> (<SPAN style="color: rgb(0, 0, 255);">int</SPAN> i = <SPAN style="color: rgb(128, 0, 128);">0</SPAN>; i &lt; n; i++<SPAN style="color: rgb(0, 0, 0);">)
    {
        printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">%d </SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">, A[i]);
    }
    printf(</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(128, 0, 0);">\n</SPAN><SPAN style="color: rgb(128, 0, 0);">"</SPAN><SPAN style="color: rgb(0, 0, 0);">);
    </SPAN><SPAN style="color: rgb(0, 0, 255);">return</SPAN> <SPAN style="color: rgb(128, 0, 128);">0</SPAN><SPAN style="color: rgb(0, 0, 0);">;
}</SPAN></PRE></DIV>
      <P>&nbsp;</P>
      <P>　　使用快速排序法对一列数字进行排序的过程：　　<IMG alt="" src="常用排序算法总结(一)%20-%20SteveWang%20-%20博客园_files/739525-20160328215109269-23458370.gif"></P>
      <P>&nbsp;</P>
      <P>　　<STRONG>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</STRONG></P>
      <P><STRONG>　　</STRONG>比如序列：{ 1, 3, 4, 2, <SPAN style="color: rgb(0, 0, 255);">8</SPAN>, 
      9, <SPAN style="color: rgb(0, 0, 255);">8</SPAN>, 7, <SPAN style="color: rgb(255, 0, 0);">5</SPAN> 
      }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</P>
      <P>&nbsp;</P>
      <BLOCKQUOTE>
        <P>　　Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</P></BLOCKQUOTE>
      <P>　　答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。&nbsp;</P>
      <P>&nbsp;</P></DIV>
      <DIV id="MySignature"></DIV>
      <DIV class="clear"></DIV>
      <DIV id="blog_post_info_block">
      <DIV id="BlogPostCategory"></DIV>
      <DIV id="EntryTag"></DIV>
      <DIV id="blog_post_info"></DIV>
      <DIV class="clear"></DIV>
      <DIV id="post_next_prev"></DIV></DIV></DIV></DIV></DIV><A 
      name="!comments"></A>
      <DIV id="blog-comments-placeholder"></DIV>
<SCRIPT type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</SCRIPT>
       
      <DIV class="commentform" id="comment_form"><A name="commentform"></A> 
      <DIV id="divCommentShow"></DIV>
      <DIV id="comment_nav"><SPAN id="span_refresh_tips"></SPAN><A id="lnk_RefreshComments" 
      onclick="return RefreshCommentList();" href="javascript:void(0);" 
      clientidmode="Static" runat="server">刷新评论</A><A onclick="return RefreshPage();" 
      href="http://www.cnblogs.com/eniac12/p/5329396.html#">刷新页面</A><A href="http://www.cnblogs.com/eniac12/p/5329396.html#top">返回顶部</A></DIV>
      <DIV id="comment_form_container"></DIV>
      <DIV class="ad_text_commentbox" id="ad_text_under_commentbox"></DIV>
      <DIV id="ad_t2"></DIV>
      <DIV id="opt_under_post"></DIV>
      <DIV class="c_ad_block" id="cnblogs_c1"></DIV>
      <DIV id="under_post_news"></DIV>
      <DIV class="c_ad_block" id="cnblogs_c2"></DIV>
      <DIV id="under_post_kb"></DIV>
      <DIV class="c_ad_block" id="HistoryToday"></DIV>
<SCRIPT type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</SCRIPT>
       </DIV></DIV></TD></TR>
  <TR>
    <TD class="FooterCell" colspan="2">
      <P id="footer">	Powered by: 	 <BR><A name="Hyperlink1" id="Footer1_Hyperlink3" 
      style="font-family: Verdana; font-size: 12px;" href="http://www.cnblogs.com/">博客园</A>
      	 <BR>Copyright © SteveWang </P></TD></TR></TBODY></TABLE></BODY></HTML>
